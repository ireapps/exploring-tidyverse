---
title: "Data analysis with dplyr"
output: 
---

If you're familiar with spreadsheets and/or SQL, you'll recognize these functions: they represent the some of the fundamental processes of data analyses in many programs.

```{r}
library(tidyverse)
```

The main functions of the tidyverse that we're going to cover are these:

-   select()
-   filter()
-   arrange()
-   group_by()
-   summarise()
-   count()
-   left_join() (and some other joins)

We'll put these functions into practice using the poverty data and salaries data; later we'll use campaign finance data to practice joins:

```{r}
poverty <- read_csv("data/poverty.csv")
salaries <- read_excel("data/salaries.xlsx", sheet=1)

# FEC campaign finance
# Note we're forcing data types on these tables: 
transactions <- read_csv("data/transactions.csv", col_types="ccccccccccccccTnccccccc")
candidates <- read_csv("data/candidates.csv", col_types = cols(.default = "c"))
```

Our goal here is to explore each of the functions mentioned above so you get a sense for what each does. We'll cover the basics but there's always more to learn.

An important note: the tidyverse works with a *pipe* which is this character `%>%`. It does what it sounds like: it sends the results of one function into the next. When asking questions of data, start with the variable name that holds your dataset and pipe it into the function(s) that help you answer your question.

### select()

Use `select()` to choose only particular columns from your data table, or to exclude columns in your results:

```{r}
poverty %>% select(state, county, population, below150)
```

Use the negative sign to exclude columns:

```{r}
poverty %>% select(-below50, -below125)
```

### filter()

Use `filter()` to subset records from your data table, such as all the counties in a single state. For example, if you only want to see counties in California:

```{r}
poverty %>% filter(state=="California")
```

Note the double equals sign, which is how R tests for sameness (whereas one equals sign assigns something to a variable, or container. There are exceptions to this rule of course but generally it's true).

You can specify multiple criteria in your filter, separated by `&` (AND) or `|` (OR):

```{r}
poverty %>% filter(state=="California" & population > 1000000)
```

```{r}
poverty %>% filter(state=="California" | state=="Oregon" | state=="Washington")
# or...
poverty %>% filter(state %in% c("California", "Oregon", "Washington"))

# to exclude those same states, use ! in front of the phrase: 
poverty %>% filter(!state %in% c("California", "Oregon", "Washington"))
```

Instead of matching exact values in filter with `==` you can use `grepl()` to look for keywords or match patterns with regular expressions; learning regular expressions requires some practice and persistence, but they are a powerful tool for filtering your data.

Remember that R is case sensitive, and that's true here as well. But `grepl()` comes with an argument that ignores case:

```{r}
osha %>% filter(grepl("fish",industry_description, ignore.case=T)) %>% 
  count(industry_description)
```

The `grepl()` function is in a family of `grep` functions that allow you to search for strings (as above) or patters. In order to search for patterns you need to learn "regular expressions", which is a whole other class. But you can use `grep()` and `grepl()` to search for keywords in a text column. `grepl()` returns TRUE or FALSE depending on whether the text matches, and `grep()` returns an index of the values that match:

```{r}
?grep
```

```{r}
a <- c("cod fishing", "salmon fishing", "fish hatcheries", "salmon hatcheries")
```

```{r}
grep("fish", a)
grepl("fish",a)

grepl("^fish", a) #starts with fish
grepl("fishing$", a) #ends with fishing
grepl()
```

### arrange()

Use `arrange()` to sort your data.

```{r}
poverty %>% arrange(population)
```

The default is ascending, so to switch to descending, use the function `desc()` like this:

```{r}
poverty %>% arrange(desc(population))
```

You can do a multi-level sort:

```{r}
poverty %>% arrange(state, desc(population))
```

### summarise()

Use `summarise()` to apply summary functions to a column in your data. `summarise()` will reduce a bunch of data to one number (a summary). You can do summarise an entire column or summarise groups by using the `group_by()` function (we'll talk about that next). Note that since the tidyverse was primarily written by a New Zealander you'll often see summarise spelled with an s, but you can also spell it with a z.

To sum up the population using the tidyverse convention of piping, you need to put the `sum()` function inside the `summarise()` function:

```{r}
poverty %>% summarise(total_pop = sum(population))
```

Try stringing functions together using the `%>%`:

```{r}
poverty %>% filter(state=="California") %>% summarise(total_pop = sum(population))
```

Within `summarise()` you can apply any number of summary functions. Here's a few: `mean()`, `median()`, `min()`, `max()`, `range()`, `n()`

What is the average population of counties in the US?

```{r}
poverty %>% summarise(avg_pop = mean(population))
```

What about just for California (or pick another state and swap out the name in the filter):

```{r}
poverty %>% filter(state=="California") %>% summarise(avg_pop = mean(population))
```

How many counties are in California?

```{r}
poverty %>% filter(state=="California") %>% summarise(counties = n())
```

### group_by()

Use `group_by()` to apply summary functions to groups rather than the whole (or filtered) dataset.

`group_by()` puts your rows into groups based on the values in some column, whatever you specify within the function. So if you want to group all the rows by state and add up the population for each:

```{r}
poverty %>% 
  group_by(state) %>% 
  summarise(total_pop = sum(population))
```

Add the `arrange()` function to sort by total population:

```{r}
poverty %>% 
  group_by(state) %>% 
  summarise(total_pop = sum(population)) %>% 
  arrange(desc(total_pop))
```

Note: because you named the result of sum(population) "total_pop", you can feed that into the `arrange()` function.

Now we'll take a look at the `salaries` data.

The `count()` function is a great tool for integrity checks. Use it to look for misspellings and inconsistencies (and also to see which values are most common). This function basically gives you the frequency of each value in a column:

```{r}
salaries %>% count(department)
```

`count()` is basically a combination of `group_by()` and `summarise(n())`. The following two lines of code produce exactly the same results:

```{r}
salaries %>% count(job_title)
salaries %>% group_by(job_title) %>% summarise(n = n())
```

What is the total overtime paid out by the city in 2021? Notice that there NAs in overtime. If you don't exclude them, R will just return an NA on any summary function you run. Use the `na.rm=TRUE` argument to exclude NAs. You can also write `na.rm=T`:

```{r}
salaries %>% summarise(overtime = sum(overtime_oncall, na.rm=TRUE))
```

Which department paid out the most in overtime pay? If you want to compare departments, you need to use the `group_by()`. The `summarise()` function will then operate on the groups rather than the whole dataset:

```{r}
salaries %>% 
  group_by(department) %>% 
  summarise(overtime = sum(overtime_oncall, na.rm=TRUE)) %>% 
  arrange(desc(overtime))
```

Which Senior Police Officers get the most overtime?

```{r}
salaries %>% 
  filter(job_title=="Senior Police Officer") %>% 
  arrange(desc(overtime_oncall))
```

Which job title received the most in overtime pay?

```{r}
salaries %>% 
  group_by(job_title) %>% 
  summarise(OT = sum(overtime_oncall, na.rm=T)) %>% 
  arrange(desc(OT))
```

Which departments pay out the most in overtime?

```{r}
salaries %>% 
  group_by(department) %>% 
  summarise(ot = sum(overtime_oncall, na.rm=T)) %>% 
  arrange(desc(ot))
```

### joins

There are several different kinds of joins in R that determine what you'll see in your results. Each join is a different function but they all use the same arguments.

-   inner_join(x,y)

-   left_join(x,y) 

-   right_join(x,y)

-   full_join(x,y)

-   semi_join(x,y)

-   anti_join(x,y)

If you know SQL some of these will look familiar. To specify which columns to join on, use `by = `. If the shared columns have the same name, for example `id`, use `by = "id"`. If the columns have different names, such as `a_id` and `b_id`, use `by = c("id" = "id2")`. If you need to join on more than one column, `by=c("id" = "id2", "name" = "name2")`.

`inner_join()` returns only matches and all the columns from both tables: 
```{r}
inner_join(transactions, candidates, by = "cand_id")
```

`left_join()` returns all the rows from your main table (or left table) and only matches from your lookup table. It also returns columns from both tables.
```{r}
left_join(transactions, candidates, by = "cand_id")
```

`right_join()` is just `left_join()` in reverse. I never use it.


